 g = gdata + gprior

so need derivative of prior function too...

To get gdata, need s1, s2, s3

sqrtW = diag(sqrt(W));
c = L\sqrtW;
R = c'*c;
C2 = diag(K) - sum((c*K).^2,1)' ;
s2 = 0.5*C2.*gp.lik.fh.llg3(gp.lik, y, f, 'latent', z)

llg3 is a third derivative ?!?


gp.cf{i} gets component of kernel?

if gpcf is a sub-kernel
gpcf.fh.cfg is a function giving the gradient wrt. x
 >> DKffc
This'll be a list of kenrel slices, each one yielding DKff
dimension of this gives number of features (np)

This must be the gradient of the likelihood wrt f
g1 = gp.lik.fh.llg(gp.lik, y, f, 'latent', z)

If 0-mean
s1 = 0.5 * a'*DKff*a - 0.5*sum(sum(R.*DKff));

Else... that weird matrix thing:
s1 = 0.5 * (a-K\(H'*b_m))'*DKff*(a-K\(H'*b_m)) - 0.5*sum(sum(R.*DKff))

b = DKff * g1

s3 = b - K*(R*b)

gradient fo the prior kernel???!?
gprior_df = =gpcf.fh.lpg(gpcf)




gdata(i1) = -(s1 + s2'*s3)






To get DKff (two-argument call)

# covariance matrix
Cdm = gpcf_sexp_trcov(gpcf, x)

Loop through the lengthscales

          for i=i1
            s = 2./gpcf.lengthScale(i).^2;             #  2 / l^2
            dist = bsxfun(@minus,x(:,i),x(:,i)');      #  d
            D = Cdm.*s.*dist.^2./2;                    # D =  Cdm 

                                 DKff[i] <- 0.5 * Cdm * (2 / l ^ 2 ) * d ^ 2

            ii1 = ii1+1;
            DKff{ii1} = D;
          end
